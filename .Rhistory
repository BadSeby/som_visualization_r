set.seed(123)
exp.k <- list()
for (i in 2:7){
exp.k[i-1] <- kmeans(x=exposure[,2:6], centers=i, iter.max= 10000, nstart=1000, trace=TRUE)
}
exp.k <- kmeans(x=exposure[,2:6], centers=i, iter.max= 10000, nstart=1000)
class(exp.k)
as.list(exp.k)
set.seed(123)
exp.k <- NA
for (i in 2:7){
km <- kmeans(x=exposure[,2:6], centers=i, iter.max= 10000, nstart=1000)
exp.k <- km$tot.withinss
}
exp.k
exp.k <- NA
for (i in 2:7){
km <- kmeans(x=exposure[,2:6], centers=i, iter.max= 10000, nstart=1000)
exp.k[i-1] <- km$tot.withinss
}
exp.k
for (i in 2:7){
assign(x=paste0("exp.k", i),
kmeans(x=exposure[,2:6], centers=i, iter.max= 10000, nstart=1000)
}
set.seed(123)
for (i in 2:7){
assign(x=paste0("exp.k", i),
value=kmeans(x=exposure[,2:6], centers=i, iter.max= 10000, nstart=1000)))
}
paste0("exp.k", i)
set.seed(123)
for (i in 2:7){
assign(x=paste0("exp.k", i),
value=kmeans(x=exposure[,2:6], centers=i,
iter.max= 10000, nstart=1000))
}
require(ggplot2)
library(cluster)
library(plyr)
library(reshape2)
############################
##LOAD DATA FROM LATENT GOLD
##IN this NOvermber RUn I didn't have time to do a latent class
############################
#class5 <- read.csv("~/Dropbox/USGS CLUSTER/Results_Cascadia_CLASSIFIED.csv")
casc <- read.csv("~/Dropbox/USGS CLUSTER/Cascadia_FOR SETH_updated.csv")
##TRANSFOM DATA
casc.z <- data.frame(scale(x=casc[,5:27]))
casc.z$Town <- casc$Town
#CREATE DOMAINS
exposure <- casc.z[, c("Town", "TOT_Res","TOT_Emp","TOT_PV","TOT_DC","TOT_CS")]
demographic <- casc.z[, c("Town","PCT_RESIDENT","PCT_HISP","PCT_AmInd","PCT_under5","PCT_SingleMom","PCT_Over65","PCT_GroupQuart","PCT_Renters")]
#housing <- casc[, c("Town","PCT_GroupQuart","PCT_Renters")]
adapt_cap <- casc.z[, c("Town","Tot_Evac_Res","Tot_Evac_Emp","Tot_Evac_PV","Tot_Evac_DC","Tot_Evac_CS")]
trav_spd <- casc.z[, c("Town","TOT_Speed_Res","TOT_Speed_Emp","TOT_Speed_PV","TOT_Speed_DC","TOT_Speed_CS")]
set.seed(123)
for (i in 2:7){
assign(x=paste0("exp.k", i),
value=kmeans(x=exposure[,2:6], centers=i,
iter.max= 10000, nstart=1000))
assign(x=paste0("demo.k", i),
value=kmeans(x=demographic[,2:9], centers=i,
iter.max= 10000, nstart=1000))
assign(x=paste0("ada.k", i),
value=kmeans(x=adapt_cap[,2:6], centers=i,
iter.max= 10000, nstart=1000))
assign(x=paste0("trav.k", i),
value=kmeans(x=trav_spd[,2:6], centers=i,
iter.max= 10000, nstart=1000))
}
ada.k2
ada.k3
ada.k4
ada.k5
ada.k6
ada.k7
ada.k5
exp.k2
exp.k3
exp.k4
exp.k5
exp.k6
exp.k7
exp.k3
demo.k2
demo.k3
demo.k4
demo.k5
demo.k6
demo.k7
set.seed(7117117)
for (i in 2:7){
assign(x=paste0("exp.k", i),
value=kmeans(x=exposure[,2:6], centers=i,
iter.max= 10000, nstart=1000))
assign(x=paste0("demo.k", i),
value=kmeans(x=demographic[,2:9], centers=i,
iter.max= 10000, nstart=1000))
assign(x=paste0("ada.k", i),
value=kmeans(x=adapt_cap[,2:6], centers=i,
iter.max= 10000, nstart=1000))
assign(x=paste0("trav.k", i),
value=kmeans(x=trav_spd[,2:6], centers=i,
iter.max= 10000, nstart=1000))
}
exp.k2
exp.k3
exp.k4
exp.k4
exp.k6
for (i in 2:10){
assign(x=paste0("exp.k", i),
value=kmeans(x=exposure[,2:6], centers=i,
iter.max= 10000, nstart=1000))
assign(x=paste0("demo.k", i),
value=kmeans(x=demographic[,2:9], centers=i,
iter.max= 10000, nstart=1000))
assign(x=paste0("ada.k", i),
value=kmeans(x=adapt_cap[,2:6], centers=i,
iter.max= 10000, nstart=1000))
assign(x=paste0("trav.k", i),
value=kmeans(x=trav_spd[,2:6], centers=i,
iter.max= 10000, nstart=1000))
}
exp.k2
exp.k3
exp.k4
exp.k5
exp.k6
exp.k7
exp.k8
exp.k9
exp.k10
exp.k3
demo.k2
demo.k3
demo.k4
demo.k5
demo.k6
demo.k7
demo.k8
demo.k9
demo.k10
demo.k4
ada.k2
ada.k3
ada.k4
ada.k5
ada.k6
ada.k5
ada.k4
trav.k2
trav.k3
trav.k4
trav.k5
trav.k6
trav.k3
trav.k4
casc$adapt_type <- ada.k4$cluster
casc$exposure_type <- exp.k3$cluster
casc$demographic_type <- demo.k4$cluster
casc$travel_type <- trav.k4$cluster
names(casc.z)
names(casc)
casc[,28:31]
table(casc[,28:31])
unique(casc[,28:31])
demo.k4
demo.k4$centers
t(demo.k4$centers)
exp.k4
exp.k3
exp.k5
exp.k4
casc$exposure_type <- exp.k4$cluster
cl.means <- cbind(t(ada.k4$means),t(exp.k4$means),t(demo.k4$means),t(trav.k4$means))
t(ada.k4$means
)
cl.means <- cbind(t(ada.k4$centers),t(exp.k4$centers),t(demo.k4$centers),t(trav.k4$centers))
cl.means <-rbind(t(ada.k4$centers),t(exp.k4$centers),t(demo.k4$centers),t(trav.k4$centers))
cl.means
(daisy(casc[,28:31], metric = "gower"))
as.matrix(daisy(casc[,28:31], metric = "gower"))
casc$adapt_type <- ada.k4$cluster
casc$exposure_type <- exp.k3$cluster
casc$demographic_type <- demo.k4$cluster
casc$travel_type <- trav.k4$cluster
type<distas.matrix(daisy(casc[,28:31], metric = "gower"))
type.dist<-as.matrix(daisy(casc[,28:31], metric = "gower"))
hclust(d=type.dist, method="wards")
hclust(d=type.dist, method="ward")
?hclust
hclust(d=type.dist, method="single")
a=hclust(d=type.dist, method="single")
type.dist
type.dist<-as.matrix(1-daisy(casc[,28:31], metric = "gower"))
type.dist
a=hclust(d=type.dist, method="single")
paste(casc[,28:31])
c(casc[,28:31])
head(casc[,28:31])
apply(X=casc[,28:31], MARGIN=1, FUN=paste0)
lapply(X=casc[,28:31], MARGIN=1, FUN=paste0)
lapply(X=casc[,28:31], MARGIN=2, FUN=paste0)
paste0(casc[,28], casc[,29], casc[,30], casc[,31])
casc$combined_type <- as.fact0r(paste0(casc[,28], casc[,29], casc[,30], casc[,31]))
casc$combined_type <- as.factor(paste0(casc[,28], casc[,29], casc[,30], casc[,31]))
head(casc)
?levels
unique(casc$combined_type)
length(unique(casc$combined_type))
casc$combined_type <- levels(A:J)
A:J
"A":"J"
LETTERS[1:12]
casc$combined_type <- levels(LETTERS[1:12])
casc$combined_type
casc$combined_type <- as.factor(paste0(casc[,28], casc[,29], casc[,30], casc[,31]))
casc$combined_type
casc$combined_type <- levels(LETTERS[1:12])
casc$combined_type
LETTERS[1:12]
casc$combined_type <- as.factor(paste0(casc[,28], casc[,29], casc[,30], casc[,31]))
casc$combined_type <- levels(c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L"))
casc$combined_type
casc$combined_type <- as.factor(paste0(casc[,28], casc[,29], casc[,30], casc[,31]))
exposure <- casc[, c("Town","exposure_type" ,"TOT_Res","TOT_Emp","TOT_PV","TOT_DC","TOT_CS")]
demographic <- casc[, c("Town", "demographic_type", "PCT_RESIDENT","PCT_HISP","PCT_AmInd","PCT_under5","PCT_SingleMom","PCT_Over65","PCT_GroupQuart","PCT_Renters")]
adapt_cap <- casc[, c("Town","adapt_type", "Tot_Evac_Res","Tot_Evac_Emp","Tot_Evac_PV","Tot_Evac_DC","Tot_Evac_CS")]
trav_spd <- casc[, c("Town", "travel_type","TOT_Speed_Res","TOT_Speed_Emp","TOT_Speed_PV","TOT_Speed_DC","TOT_Speed_CS")]
zScore <- Vectorize(function(x){(x-mean(x))/(sd(x))})
range01 <- Vectorize(function(x){(x-min(x))/(max(x)-min(x))})
plotBoxs <- function(inData){
econz <- cbind(inData[,1:2], zScore(inData[,3:length(inData)]))
econM <- melt(econz, id=c("Town", "type" ))
plot1 <- ggplot(econM, aes(group=variable, x=variable, y=value, fill=variable))
plot1 + geom_boxplot() + facet_grid(. ~ type, scales="free") + opts(
axis.text.x = theme_text(size=8, angle=45, hjust=1, vjust=1),
title="Cascadia Tsunami Zone\nCommunity Types") +
ylab("Variable Mean (Standard Score)") +
xlab("Variables by Community Type")
ggsave(paste("~/Dropbox/USGS CLUSTER/", deparse(substitute(inData)), "Altgraph.pdf", sep = ""))
}
plotBoxs(exposure)
plotBoxs(demographic)
plotBoxs(adapt_cap)
plotBoxs(trav_spd)
plotBoxs <- function(inData, type_field){
econz <- cbind(inData[,1:2], zScore(inData[,3:length(inData)]))
econM <- melt(econz, id=c("Town", type_field ))
plot1 <- ggplot(econM, aes(group=variable, x=variable, y=value, fill=variable))
plot1 + geom_boxplot() + facet_grid(. ~ type_field, scales="free") + opts(
axis.text.x = theme_text(size=8, angle=45, hjust=1, vjust=1),
title="Cascadia Tsunami Zone\nCommunity Types") +
ylab("Variable Mean (Standard Score)") +
xlab("Variables by Community Type")
ggsave(paste("~/Dropbox/USGS CLUSTER/", deparse(substitute(inData)), "Altgraph.pdf", sep = ""))
}
plotBoxs(exposure)
plotBoxs(exposure, "exposure_type")
names(exposure)[2]
names(exposure)[2] <- "type"
names(exposure)[2]
names(demographic)[2] <- "type"
names(adapt_cap)[2] <- "type"
names(trav_spd)[2] <- "type"
zScore <- Vectorize(function(x){(x-mean(x))/(sd(x))})
range01 <- Vectorize(function(x){(x-min(x))/(max(x)-min(x))})
##HELPER FUNCTION
plotBoxs <- function(inData){
econz <- cbind(inData[,1:2], zScore(inData[,3:length(inData)]))
econM <- melt(econz, id=c("Town", "type" ))
plot1 <- ggplot(econM, aes(group=variable, x=variable, y=value, fill=variable))
plot1 + geom_boxplot() + facet_grid(. ~ type, scales="free") + opts(
axis.text.x = theme_text(size=8, angle=45, hjust=1, vjust=1),
title="Cascadia Tsunami Zone\nCommunity Types") +
ylab("Variable Mean (Standard Score)") +
xlab("Variables by Community Type")
ggsave(paste("~/Dropbox/USGS CLUSTER/", deparse(substitute(inData)), "Altgraph.pdf", sep = ""))
}
plotBoxs(exposure)
names(casc)
combined <- casc[, c(1,5:27,31)]
combined <- casc[, c(1,31,5:27)]
names(combined)[2] <- "type"
plotBoxs(combined)
plotBoxs(demographic)
plotBoxs(adapt_cap)
plotBoxs(trav_spd)
plotBoxs(combined)
plotBar <- function(inData){
econz <- cbind(inData[,1:2], zScore(inData[,3:length(inData)]))
econM <- melt(econz, id=c("Town", "type" ))
plot1 <- ggplot(econM, aes(group=variable, x=variable, y=value, fill=variable))
plot1 + stat_summary(fun.y = "mean", geom="bar") + facet_grid(. ~ type) + opts(
axis.text.x = theme_text(size=8, angle=45, hjust=1, vjust=1),
title="Cascadia Tsunami Zone\nCommunity Types") +
ylab("Variable Mean (Standard Score)") +
xlab("Variables by Community Type")
ggsave(paste("~/Dropbox/USGS CLUSTER/", deparse(substitute(inData)), "graph.pdf", sep = ""))
}
plotBar(exposure)
plotBar(demographic)
plotBar(housing)
plotBar(adapt_cap)
plotBar(trav_spd)
plotBar(combined)
write.csv(casc, file="~/Dropbox/USGS CLUSTER/December9Classes.csv")
casc$combined_type
names(casc)[31]
names(casc)[32]
combined <- casc[, c(1,32,5:27)]
names(combined)
names(combined)[2] <- "type"
plotBoxs(combined)
plotBar(combined)
plotBar <- function(inData){
econz <- cbind(inData[,1:2], zScore(inData[,3:length(inData)]))
econM <- melt(econz, id=c("Town", "type" ))
plot1 <- ggplot(econM, aes(group=variable, x=variable, y=value, fill=variable))
plot1 + stat_summary(fun.y = "mean", geom="bar") + facet_grid(. ~ type) + opts(
axis.text.x = theme_text(size=8, angle=45, hjust=1, vjust=1),
title="Cascadia Tsunami Zone\nCommunity Types") +
ylab("Variable Mean (Standard Score)") +
xlab("Variables by Community Type")
ggsave(paste("~/Dropbox/USGS CLUSTER/", deparse(substitute(inData)), "graph.pdf", sep = ""), width=18)
}
plotBar(exposure)
plotBar(demographic)
plotBar(housing)
plotBar(adapt_cap)
plotBar(trav_spd)
plotBar(combined)
plotBar <- function(inData){
econz <- cbind(inData[,1:2], zScore(inData[,3:length(inData)]))
econM <- melt(econz, id=c("Town", "type" ))
plot1 <- ggplot(econM, aes(group=variable, x=variable, y=value, fill=variable))
plot1 + stat_summary(fun.y = "mean", geom="bar") + facet_grid(. ~ type) + opts(
axis.text.x = theme_text(size=8, angle=45, hjust=1, vjust=1),
title="Cascadia Tsunami Zone\nCommunity Types") +
ylab("Variable Mean (Standard Score)") +
xlab("Variables by Community Type")
ggsave(paste("~/Dropbox/USGS CLUSTER/", deparse(substitute(inData)), "graph.pdf", sep = ""), width=18, height=10)
}
plotBar(exposure)
plotBar(demographic)
plotBar(housing)
plotBar(adapt_cap)
plotBar(trav_spd)
plotBar(combined)
##HELPER FUNCTION
plotBoxs <- function(inData){
econz <- cbind(inData[,1:2], zScore(inData[,3:length(inData)]))
econM <- melt(econz, id=c("Town", "type" ))
plot1 <- ggplot(econM, aes(group=variable, x=variable, y=value, fill=variable))
plot1 + geom_boxplot() + facet_grid(. ~ type, scales="free") + opts(
axis.text.x = theme_text(size=8, angle=45, hjust=1, vjust=1),
title="Cascadia Tsunami Zone\nCommunity Types") +
ylab("Variable Mean (Standard Score)") +
xlab("Variables by Community Type")
ggsave(paste("~/Dropbox/USGS CLUSTER/", deparse(substitute(inData)), "Altgraph.pdf", sep = ""), , width=18, height=10)
}
plotBoxs(exposure)
plotBoxs(demographic)
plotBoxs(adapt_cap)
plotBoxs(trav_spd)
plotBoxs(combined)
q()
data(wines)
set.seed(7)
kohmap <- xyf(scale(wines), classvec2classmat(wine.classes),
grid = somgrid(5, 5, "hexagonal"), rlen=100)
plot(kohmap, type="changes")
plot(kohmap, type="codes", main = c("Codes X", "Codes Y"))
plot(kohmap, type="counts")
## palette suggested by Leo Lopes
coolBlueHotRed <- function(n, alpha = 1) {
rainbow(n, end=4/6, alpha=alpha)[n:1]
}
plot(kohmap, type="quality", palette.name = coolBlueHotRed)
plot(kohmap, type="mapping",
labels = wine.classes, col = wine.classes+1,
main = "mapping plot")
## add background colors to units according to their predicted class labels
xyfpredictions <- classmat2classvec(predict(kohmap)$unit.predictions)
bgcols <- c("gray", "pink", "lightgreen")
plot(kohmap, type="mapping", col = wine.classes+1,
pchs = wine.classes, bgcol = bgcols[as.integer(xyfpredictions)],
main = "another mapping plot")
## Show 'component planes'
set.seed(7)
sommap <- som(scale(wines), grid = somgrid(6, 4, "hexagonal"))
plot(sommap, type = "property", property = sommap$codes[,1],
main = colnames(sommap$codes)[1])
## Another way to show clustering information
plot(sommap, type="dist.neighbours", main = "SOM neighbour distances")
## use hierarchical clustering to cluster the codebook vectors
som.hc <- cutree(hclust(dist(sommap$codes)), 5)
add.cluster.boundaries(sommap, som.hc)
## and the same for rectangular maps
set.seed(7)
sommap <- som(scale(wines),grid = somgrid(6, 4, "rectangular"))
plot(sommap, type="dist.neighbours", main = "SOM neighbour distances")
## use hierarchical clustering to cluster the codebook vectors
som.hc <- cutree(hclust(dist(sommap$codes)), 5)
add.cluster.boundaries(sommap, som.hc)
library(kohonen)
data(wines)
set.seed(7)
kohmap <- xyf(scale(wines), classvec2classmat(wine.classes),
grid = somgrid(5, 5, "hexagonal"), rlen=100)
plot(kohmap, type="changes")
plot(kohmap, type="codes", main = c("Codes X", "Codes Y"))
## palette suggested by Leo Lopes
coolBlueHotRed <- function(n, alpha = 1) {
rainbow(n, end=4/6, alpha=alpha)[n:1]
}
plot(kohmap, type="quality", palette.name = coolBlueHotRed)
plot(kohmap, type="mapping",
labels = wine.classes, col = wine.classes+1,
main = "mapping plot")
## add background colors to units according to their predicted class labels
xyfpredictions <- classmat2classvec(predict(kohmap)$unit.predictions)
bgcols <- c("gray", "pink", "lightgreen")
plot(kohmap, type="mapping", col = wine.classes+1,
pchs = wine.classes, bgcol = bgcols[as.integer(xyfpredictions)],
main = "another mapping plot")
## Show 'component planes'
set.seed(7)
sommap <- som(scale(wines), grid = somgrid(6, 4, "hexagonal"))
plot(sommap, type = "property", property = sommap$codes[,1],
main = colnames(sommap$codes)[1])
## Another way to show clustering information
plot(sommap, type="dist.neighbours", main = "SOM neighbour distances")
## use hierarchical clustering to cluster the codebook vectors
som.hc <- cutree(hclust(dist(sommap$codes)), 5)
add.cluster.boundaries(sommap, som.hc)
## and the same for rectangular maps
set.seed(7)
sommap <- som(scale(wines),grid = somgrid(6, 4, "rectangular"))
plot(sommap, type="dist.neighbours", main = "SOM neighbour distances")
## use hierarchical clustering to cluster the codebook vectors
som.hc <- cutree(hclust(dist(sommap$codes)), 5)
add.cluster.boundaries(sommap, som.hc)
wine.classes
sommap$unit.classif
plot.kohonen
library(kohnen)
library(kohonen)
plot.kohonen
plot.kohmappin
plot.kohmapping
load("~/Dropbox/Brundson Singleton Geocomputation Chapter/som.rdata")
aSom$distances
dim(aSom$distances)
class(aSom$distances)
head(aSom$distances)
d <- dist(aSom$codes)
d
head(dist)
head(d)
sammon(d)
??sammon
library(MASS)
sammon(d)
plot(sammon(d))
ds <- sammon(d)
plot(ds, type="n")
head(ds)
plot(x=ds[,1], y=ds[,2], type="n")
plot(x=ds$points[,1], y=ds$points[,2], type="n")
plot(x=ds$points[,1], y=ds$points[,2])
d <- dist(aSom$codes)
d
head(d)
dim(d)
d
d <- dist(aSom$codes, upper=TRUE)
d
dim(d)
ds <- sammon(d)
plot(ds)
plot(x=ds$points[,1], y=ds$points[,2])
image(ds)
image(as.matrix(ds))
as.matrix(d)
image(as.matrix(d))
ds <- sammon(as.matrix(d))
plot(x=ds$points[,1], y=ds$points[,2])
?plot(kohonen)
?plot.kohonen
?plot.kohonen
??plot.kohonen
plot(aSom, type="dist.neighbors")
plot(aSom, type="dist.neighbors")
library(kohonen)
plot(aSom, type="dist.neighbors")
plot(aSom, type="dist.neighbours")
plot(aSom, type="dist.neighbours")
plot(aSom, type="dist.neighbours")
RHome
R.home
R.home()
source("./somComponentPlanePlottingFunction.R")
source("/somComponentPlanePlottingFunction.R")
source("somComponentPlanePlottingFunction.R")
setwd("~/Dropbox/Brundson Singleton Geocomputation Chapter/som_visualization_r")
source("somComponentPlanePlottingFunction.R")
source("Map_COUNTY_BMU.R")
source("plotUMatrix.R")
install.packages("fields")
